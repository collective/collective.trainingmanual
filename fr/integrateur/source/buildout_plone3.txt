.. -*- coding: utf-8 -*-

.. _buildout_plone3:

==========================================
Création d'un buildout Plone avec ZopeSkel
==========================================

:Author: Vincent Fretin
:Contributors:
:Version: 1.0.0
:Révision: `<https://svn.plone.org/svn/collective/collective.trainingmanual/trunk/fr/integrateur/source/presentation_plone.txt>`_

Copyright (C) 2010 Vincent Fretin <vincentfretin AT ecreall.com>.

Chacun est autorisé à copier, distribuer et/ou modifier ce document
suivant les termes de la licence Paternité-Pas
d'Utilisation Commerciale-Partage des Conditions Initiales à l'Identique 2.0
France accessible à http://creativecommons.org/licenses/by-nc-sa/2.0/fr

Le code source présent dans ce document est soumis aux conditions de
la « Zope Public License », Version 2.1 (ZPL).

THE SOURCE CODE IN THIS DOCUMENT AND THE DOCUMENT ITSELF IS PROVIDED
"AS IS" AND ANY AND ALL EXPRESS OR IMPLIED WARRANTIES ARE DISCLAIMED,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS FOR A PARTICULAR
PURPOSE.

.. contents:: :local:

.. note::

    Ce chapitre utilise un dépôt subversion créé dans le chapitre
    `La gestion des sources avec subversion
    <http://docs.ecreall.com/developpeur/gestion_des_sources.html>`__
    ainsi qu'un Pypi privé créé via :ref:`PloneSoftwareCenter`.

Création du buildout
====================

Créez les répertoires buildouts et packages sur le dépôt subversion :

.. code-block:: sh

    $ svn mkdir http://devagile/Formation/buildouts
    $ svn mkdir http://devagile/Formation/packages

Commandes :

.. code-block:: sh

    $ paster create -t plone3_buildout plone4 --svn-repository=http://devagile/Formation/buildouts/
    Selected and implied templates:
      ZopeSkel#plone3_buildout  A buildout for Plone 3 installation

    Variables:
      egg:      plone4
      package:  plone4
      project:  plone4
    Running:
    svn mkdir ...
    Expert Mode? (What question mode would you like? (easy/expert/all)?) ['easy']:
    Plone Version (Plone version # to install) ['3.3.5']: 4.0.1
    Zope2 Install Path (Path to Zope2 installation; leave blank to fetch one!) ['']:
    Plone Products Directory (Path to Plone products; leave blank to fetch [Plone 3.0/3.1 only]) ['']:
    Initial Zope Username (Username for Zope root admin user) ['admin']:
    Initial User Password (Password for Zope root admin user) ['']: admin
    HTTP Port (Port that Zope will use for serving HTTP) ['8080']:
    Debug Mode (Should debug mode be "on" or "off"?) ['off']:
    Verbose Security? (Should verbose security be "on" or "off"?) ['off']:
    Creating template plone3_buildout
      Copying README.txt to ./plone4/README.txt
      Copying bootstrap.py to ./plone4/bootstrap.py
      Copying buildout.cfg_tmpl to ./plone4/buildout.cfg
      Recursing into products
        Creating ./plone4/products/
        Copying README.txt to ./plone4/products/README.txt
      Recursing into src
        Creating ./plone4/src/
        Copying README.txt to ./plone4/src/README.txt
      Recursing into var
        Creating ./plone4/var/
        Copying README.txt to ./plone4/var/README.txt

    **************************************************************************
    **   Generation finished.

    **  You probably want to run python bootstrap.py and then edit
    **  buildout.cfg before running bin/buildout -v".

    **  See README.txt for details.
    **************************************************************************

.. note::

	Avec l'option --svn-directory,
	un bug connu de Paste-1.7.3 et ZopeSkel-2.16
	produit l'erreur suivante à la fin du processus :

	IOError: No egg-info directory found

	Vous pouvez simplement l'ignorer.

Vous allez éditer un peu le fichier :file:`buildout.cfg` avant d'amorcer
le buildout.

Créez un fichier :file:`versions.cfg` que vous utiliserez
pour gelez les versions des modules, pour l'instant vide :

.. code-block:: cfg

    [versions]

Dans :file:`buildout.cfg`, modifiez la variable :data:`extends` en :

.. code-block:: cfg

   [buildout]
   # ...
   extends =
       http://dist.plone.org/release/4.0.1/versions.cfg
       versions.cfg

Si vous voulez travailler sur la dernière version du fichier versions.cfg de
Plone, vous pouvez le télécharger comme ceci :

.. code-block:: sh

    $ svn cat \
    http://svn.plone.org/svn/plone/buildouts/plone-coredev/branches/4.0/versions.cfg \
    > versions-plone.cfg

et changez votre :file:`buildout.cfg` pour que l'option extends ressemeble à
ceci :

.. code-block:: cfg

    extends =
        versions-plone.cfg
        versions.cfg

Ajoutez :

.. code-block:: cfg

   [buildout]
   # ...
   eggs =
       PIL

PIL est téléchargé depuis http://dist.plone.org/thirdparty.
L'archive PIL téléchable sur pypi.python.org n'est pas easy_installable.

La section ``[productdistros]`` est utilisée pour installer des produits Zope
non encore eggifiés, rare de nos jours.

Le :file:`buildout.cfg` minimal que vous devez obtenir :

.. code-block:: cfg

    [buildout]
    parts =
        instance
        zopepy
    extends =
        http://dist.plone.org/release/4.0.1/versions.cfg
        versions.cfg
    versions = versions
    find-links =
        http://dist.plone.org/release/4.0.1
        http://dist.plone.org/thirdparty
    eggs = PIL

    [instance]
    recipe = plone.recipe.zope2instance
    user = admin:admin
    http-address = 8080
    eggs =
        Plone
        ${buildout:eggs}
    environment-vars =
        zope_i18n_compile_mo_files true
    zcml =

    [zopepy]
    recipe = zc.recipe.egg
    eggs = ${instance:eggs}
    interpreter = zopepy
    scripts = zopepy

Amorcez et lancez buildout :

.. code-block:: sh

    $ cd plone4
    $ python2.6 bootstrap.py -d
    $ bin/buildout
    $ ls -F
    bin/          buildout.cfg   parts/ README.txt  var/
    bootstrap.py  develop-eggs/  products/  src/        versions.cfg
    $ ls parts
    buildout  instance
    $ ls bin
    buildout  instance  zopepy

- :command:`instance` : script pour contrôler l'instance zope
- :command:`zopepy` : interpréteur python avec l'ensemble des eggs dans le
  :data:`sys.path`

Démarrez l'instance avec ``bin/instance fg`` et connectez vous à http://localhost:8080
pour créer votre site Plone.

.. note::

    Commitez votre buildout

    .. code-block:: sh

        svn ci -m"Created initial buildout structure"

Installation de produits tierces
================================

Prenons le produit `FCKeditor`_ comme exemple.

Stoppez l'instance avec Ctrl+C.

Ajoutez ``Products.FCKeditor`` dans l'option *eggs* de la section ``[instance]``
et reexécutez le buildout :

.. code-block:: sh

    $ bin/buildout

Démarrez l'instance :

.. code-block:: sh

    $ bin/instance fg

Pour les produits n'étant pas dans l'espace de nom (namespace en anglais)
*Products*, il faut également l'ajouter dans l'option zcml.

À moins que le produit se proclame plugin plone comme c'est le cas
des modules créés avec la commande :command:`paster` que vous verrez dans
la suite. Dans ce cas-là les fichiers zcml seront inclus grâce à
:mod:`z3c.autoinclude`.

.. _`FCKeditor`: http://pypi.python.org/pypi/Products.FCKeditor

Création d'un policy product contenant la configuration du site Plone
=====================================================================

Vous allez créer un :term:`policy product` contenant la configuration du site
Plone.

Dans ce :term:`policy product`, nous allons aussi dire d'installer
automatiquement les produits :mod:`Products.Collage` et
:mod:`Products.FCKeditor` lors de l'installation du produit.

Nous allons ensuite configurer FCKeditor comme éditeur par défaut pour les
utilisateurs nouvellement créés.

Création du policy package
--------------------------

Créez le policy package :

.. code-block:: sh

    $ cd /tmp/
    $ paster create -t plone formation.policy \
      --svn-repository=http://devagile/Formation/packages
    Expert Mode? (What question mode would you like? (easy/expert/all)?) ['easy']:
    Version (Version number for project) ['1.0']:
    Description (One-line description of the project) ['']: Projet exemple pour la formation integrateur
    Register Profile (Should this package register a GS Profile) [False]: True
    $ cd formation.policy
    $ svn rm --force formation.policy.egg-info
    $ svn ci -m "Add initial structure for formation.policy"

Le template :option:`plone` hérite du template :option:`basic_namespace`, il
ajoute en plus un fichier :file:`configure.zcml`.

.. note::
   utilisation de ``svn:externals``

   utilisation de :option:`svn:externals` pour faire une sorte de checkout dans
   le dossier src :

.. code-block:: sh

    $ cd ~/workspace/plone4/src/
    $ vim EXTERNALS.txt
    formation.policy http://devagile/Formation/packages/formation.policy/trunk
    $ svn propset svn:externals -F EXTERNALS.txt .
    $ svn up
    $ svn add EXTERNALS.txt
    $ svn ci -m"Set svn:externals on src directory to install formation.policy"

Ajoutez :mod:`Products.Collage` et :mod:`Products.FCKeditor` en dépendances
de :mod:`formation.policy` dans le fichier :file:`src/formation.policy/setup.py`
(option install_requires).

Lorsque vous êtes dans le dossier src, la commande :command:`svn stat` vous
renvoie les changements fait dans les externals, ici les changements de
:mod:`formation.policy` s'il y en a.

La commande :command:`svn up` sera également fait dans les différents externals.
La seule exception est la commade :command:`svn ci` exécutée à partir du dossier
:file:`src` ou plus en amont, les fichiers modifiés ou ajoutés dans les
externals ne seront pas commités.

Il faut vraiment être à l'intérieur de l'external, ici le dossier
:mod:`formation.policy` pour que le commit des changements soit réalisé.

Ceci dit, commitez le changement fait au fichier :file:`setup.py`.

Editez buildout.cfg pour ajouter *formation.policy* :

.. code-block:: cfg

    [buildout]
    #...
    develop += src/formation.policy

    [instance]
    #...
    eggs =
        #...
        formation.policy
    zcml =
        formation.policy

Exécutez :command:`bin/buildout`.

L'ajout de :mod:`formation.policy` dans l'option ``zcml = ...`` génère un *ZCML
slug*, fichier XML contenant une seule ligne :

.. centered:: :file:`parts/instance/etc/package-includes/001-formation.policy-configure.zcml`

.. code-block:: xml

    <include package="formation.policy" file="configure.zcml" />

En fait au démarrage de l'instance Zope, le fichier
:file:`parts/instance/etc/site.zcml` est lu, ce qui entraine la lecture de tous
les fichiers situés dans le dossier :file:`package-includes`, ainsi que les
fichiers :file:`meta.zcml`, :file:`configure.zcml` et :file:`overrides.zcml` des
produits dans l'espace de nom ``Products``.

La chaine de lecture est donc celle-ci :

- :file:`parts/instance/etc/site.zcml`
- :file:`parts/instance/etc/package-includes/001-formation.policy-configure.zcml`
- :file:`src/formation.policy/formation/policy/configure.zcml`

Ces fichiers ZCML sont les fichiers de configuration utilisés par la ZCA
(Zope Component Architecture) pour enregistrer les composants au démarrage.

Installation de Products.Collage à l'installation de formation.policy
---------------------------------------------------------------------

Vous allez maintenant dire à Plone d'installer :mod:`Products.Collage`
lorsque vous installez :mod:`formation.policy`.

Ouvrez le fichier :file:`src/formation.policy/formation/policy/configure.zcml`,
vous avez normalement ceci :

.. code-block:: xml

    <configure
        xmlns="http://namespaces.zope.org/zope"
        xmlns:five="http://namespaces.zope.org/five"
        xmlns:i18n="http://namespaces.zope.org/i18n"
        xmlns:genericsetup="http://namespaces.zope.org/genericsetup"
        i18n_domain="formation.policy">

      <five:registerPackage package="." initialize=".initialize" />

      <genericsetup:registerProfile
          name="default"
          title="formation.policy"
          directory="profiles/default"
          description="Installs the formation.policy package"
          provides="Products.GenericSetup.interfaces.EXTENSION"
          />
      <!-- -*- extra stuff goes here -*- -->

    </configure>

La directive ``<five:registerPackage ..../>`` signale à Zope que c'est un
module. Cette ligne est importante vu que nous ne sommes pas dans l'espace
de nom Products.

La directive ``<genericsetup:registerProfile .../>`` permet d'enregistrer un
nouveau profil d'extension (option ``provides``) avec le nom ``default``
(option ``name``). Les fichiers du profil se trouvent dans le dossier
:file:`profiles/default`. (option ``directory``).

Dans :file:`profiles/default`, éditez le fichier :file:`metadata.xml`
comme ceci :

.. code-block:: xml

    <?xml version="1.0"?>
    <metadata>
      <version>1000</version>
      <dependencies>
        <dependency>profile-Products.Collage:default</dependency>
      </dependencies>
    </metadata>

Le produit :mod:`Products.Collage` utilise bien un profil donc nous
pouvons l'installer de cette manière.

Jetez un œil à la seule documentation qui existe sur le `support des dépendances
de produits dans metadata.xml`_.

Notez que la *best practice* est maintenant d'utiliser un entier pour la version
du profile : 1000, 1001, 1002 et 2000, 2001 pour une branche parallèle.
ArchGenXML ne respecte pas encore cette convention, il faut au moins deux entiers
séparés par un point, ex : 1.0. Ce sera sans doute corrigé dans une prochaine
version.

Dans la chaine ``profile-Products.Collage:default``, nous avons le préfixe
``profile-``, le package au sens Python :mod:`Products.Collage`, le
caratère ``:`` et le nom du profil à charger ``default``.  Ici ``default`` est
le ``name`` donné lors du ``genericsetup:registerProfile`` dans le fichier
:file:`configure.zcml` de :mod:`Products.Collage`.

.. _`support des dépendances de produits dans metadata.xml`: http://plone.org/products/plone/roadmap/195

Déclaration de formation.policy comme plugin Plone
--------------------------------------------------

Plone 3.3 inclut un nouveau `système de plugin`_. Un produit peut être déclaré
plugin Plone.

Dans ce cas les fichiers :file:`meta.zcml`, :file:`configure.zcml` et
:file:`overrides.zcml` du produit seront lus au démarrage, comme pour les
produits dans l'espace de nom ``Products``.

Il n'est plus nécessaire d'ajouter le produit dans l'option ``zcml`` de la
section ``[instance]`` dans :file:`buildout.cfg`.

.. _`système de plugin`: http://plone.org/products/plone/roadmap/247

Pour cela vérifiez que le egg est déclaré comme plugin plone, avec dans :file:`src/formation.policy/setup.py` :

.. code-block:: python

    entry_points="""
    [z3c.autoinclude.plugin]
    target = plone
    """

Supprimez ``formation.policy`` de l'option ``zcml`` de la section ``[instance]``
dans :file:`buildout.cfg`.

Et relancez ``bin/buildout`` qui va supprimer le fichier
:file:`parts/instance/etc/package-includes/001-formation.policy-configure.zcml`.

La commande regénère également les metadonnées associées aux eggs en
développement, concrètement il regénére le fichier
:file:`src/formation.policy/formation.policy.egg-info/entry_points.txt` qui
déclare le egg comme plugin Plone.

À quel moment est lu le fichier :file:`configure.zcml` de
:mod:`formation.policy` ? Il n'y a rien de magique, la chaine de lecture
est maintenant :

- :file:`parts/instance/etc/site.zcml`
- lecture des fichiers :file:`configure.zcml` de tous les produits dans l'espace de nom ``Products``
- :file:`~/.buildout/eggs/Plone-4.0.1-py2.6.egg/Products/CMFPlone/configure.zcml`
  qui contient les lignes :

.. code-block:: xml

    <!-- include plone plugins with z3c.autoinclude -->
    <includePlugins
        zcml:condition="not-have disable-autoinclude"
        package="plone"
        file="configure.zcml"
        />

.. note::
   includePlugins

   ``includePlugins`` est une nouvelle directive fournie par
   :mod:`z3c.autoinclude`. Ici tous les eggs ayant un entry point dans le
   groupe ``z3c.autoinclude.plugin`` sont recherchés.  Nous avons dans cette
   directive ``package="plone"`` donc seul les entry points avec ``target =
   plone`` sont gardés. Pour chaque eggs, le fichier :file:`configure.zcml`
   (option ``file`` de la directive) est lu.

- :file:`src/formation.policy/formation/policy/configure.zcml`

Vous avez le même principe pour les fichiers :file:`meta.zcml` et
:file:`overrides.zcml`, jetez un œil dans :file:`Products/CMFPlone/meta.zcml` et
:file:`Products/CMFPlone/overrides.zcml`.

Installation de Products.FCKeditor à l'installation de formation.policy
-----------------------------------------------------------------------

Pour dépendre de :mod:`Products.FCKeditor`, nous ne pouvons pas utiliser cette
méthode car :mod:`Products.FCKeditor` n'utilise pas de profil, mais l'ancien
dossier Extensions pour être installé via le tool ``portal_quickinstaller``.

Il existe un produit pour installer des vieux produits à partir d'un profil :
`genericsetup.quickinstaller`_.

Ce produit enregistre un nouvel ``importStep`` dans ``portal_setup`` qui regarde
lors de l'installation d'un produit s'il existe un fichier :file:`products.xml`
dans le dossier du profile.

Pour que cela marche, il faut que le fichier :file:`configure.zmcl` de
:mod:`genericsetup.quickinstaller` soit lu d'une manière ou d'une autre au
démarrage.

Ajoutez :mod:`genericsetup.quickinstaller` dans :file:`setup.py`
``install_requires`` du :term:`policy product`.

Il faut donc lire le fichier :file:`configure.zmcl` du produit
:mod:`genericsetup.quickinstaller`, vous pouvez ajouter dans
:file:`src/formation.policy/formation/policy/configure.zcml`, cette directive :

.. code-block:: xml

    <include package="genericsetup.quickinstaller" />

Ici l'option ``file`` n'est pas précisée, la valeur par défaut étant
``file="configure.zcml"``.

L'inconvénient de cette ligne est que vous avez l'information
:mod:`genericsetup.quickinstaller` à deux endroits, une première fois dans le
fichier :file:`setup.py` et une deuxième fois dans :file:`configure.zmcl`.

Plone 3.3 inclu le package :mod:`z3c.autoinclude` qui permet de ne pas se
répéter. En lieu et place de la ligne ci-dessus, vous pouvez utiliser celle-ci
:

.. code-block:: xml

    <includeDependencies package="." />

Cette directive recupère la liste des dépendances du egg. Petit rappel, il le
récupère à partir du fichier
:file:`src/formation.policy/formation.policy.egg-info/requires.txt` qui lui a
été généré à partir des informations de :file:`setup.py`.

Pour chaque dépendance dans l'ordre déclaré, elle va inclure dans l'ordre les
fichiers :file:`meta.zcml`, :file:`configure.zmcl` et :file:`overrides.zcml`
s'ils existent.

Pour finir, créez un fichier :file:`profiles/default/products.xml` qui sera lu
par l'importStep enregistré par :mod:`genericsetup.quickinstaller` :

.. code-block:: xml

    <?xml version="1.0"?>
    <products>
      <installs>
        <product name="FCKeditor" />
      </installs>
    </products>

.. _`genericsetup.quickinstaller`: http://pypi.python.org/pypi/genericsetup.quickinstaller

Configuration de FCKeditor pour tous les nouveaux utilisateurs
--------------------------------------------------------------

Vous allez configurer FCKeditor comme éditeur par défaut (seulement effectif
pour les nouveaux utilisateurs).

Allez dans la ZMI, dans :guilabel:`portal_memberdata`, cliquez sur l'onglet
:guilabel:`Properties`.

Éditez la propriété :guilabel:`wysiwyg_editor`, mettez la valeur ``FCKeditor``.

Maintenant vous allez exporter cette configuration dans votre policy product.
Allez dans la ZMI, :guilabel:`portal_setup`, onglet :guilabel:`Export`,
sélectionnez le step :guilabel:`MemberData properties`, et cliquez sur
:guilabel:`Export selected steps`.

Téléchargez l'archive tar.gz proposée, extrayez son contenu dans un dossier
temporaire et copiez le fichier :file:`memberdata_properties.xml` dans le
dossier :file:`profiles/default` de votre :term:`policy product`.

Éditez le fichier pour ne laisser que la propriété qui vous intéresse.  Vous
devez donc avoir au final un fichier
:file:`profiles/default/memberdata_properties.xml` avec ce contenu :

.. code-block:: xml

    <?xml version="1.0"?>
    <object name="portal_memberdata" meta_type="PlonePAS MemberData Tool">
     <property name="wysiwyg_editor" type="string">FCKeditor</property>
    </object>

Vous pouvez exporter de cette façon presque la totalité des configurations des
tools Plone.

Pour être sûr que l'import fonctionne bien, remettez ``TinyMCE`` dans
:guilabel:`wysiwyg_editor` en ZMI.

Comme vous avez ajouté un fichier dans le profil, incrémentez la version dans
:file:`metadata.xml`, nous avons donc la version 1001.

Maintenant si vous redémarrez l'instance et que vous allez dans
:guilabel:`Configuration du site`, :guilabel:`Modules`, vous pouvez y lire :

- formation.policy 1.0
  Ce module a été mis à jour. L'ancienne version du profil est 1000. La nouvelle version du profil est 1001. Il n'y a pas de procédure de mise à jour pour ce module. Merci de consulter la documentation du module pour la mise à jour, ou contacter l'auteur du module.

Il faut en effet écrire un procédure de migration de la version 1000 vers la version 1001.

Ajoutez dans :file:`configure.zcml` :

.. code-block:: xml

  <genericsetup:upgradeDepends
      title="formation.policy 1000 to 1001"
      description="Configure FCKeditor as default wysiwyg editor"
      profile="formation.policy:default"
      source="1000"
      destination="1001"
      import_steps="memberdata-properties" />

.. note::

    Il y a un bogue dans Products.GenericSetup 1.6.1 fourni avec Plone 4.0.1.
    Ouvrez le fichier :file:`Products/GenericSetup/upgrade.py` et remplacez
    ligne 220 ``if type(step) == UpgradeStep:`` par ``isinstance(step, UpgradeEntity):``

Si vous redémarrez l'instance, vous aurez :

- formation.policy 1.0
  Ce module a été mis à jour. L'ancienne version du profil est 1000. La nouvelle version du profil est 1001. Mettre à jour : formation.policy

Vous n'avez plus qu'à cliquer sur le bouton pour mettre à jour votre module.
L'option :guilabel:`wysiwyg_editor` devrait maintenant être ``FCKeditor``.

.. note::

    Liste des import steps :

    [u'typeinfo', u'tinymce_settings', u'atcttool', u'actions', u'skins', u'factorytool', u'placeful_workflow', u'componentregistry', u'controlpanel', u'placeful_marker', u'jsregistry', u'action-icons', u'cmfeditions_various', u'reference_catalog', u'viewlets', u'content', u'propertiestool', u'various', u'portlets', u'content_type_registry', u'plone-final', u'kssregistry', u'ploneopenid-various', u'update-workflow-rolemap', u'sharing', u'uid_catalog', u'workflow', u'cssregistry', u'contentrules', u'cookie_authentication', u'catalog', u'difftool', u'plone-content', u'toolset', u'properties', u'jquerytools-various', u'tinymce_various', u'browserlayer', u'plone-difftool', u'memberdata-properties', u'kss_mimetype', u'caching_policy_mgr', u'archetypetool', u'mailhost', u'rolemap', u'various-calendar', u'qiproducts', u'archetypes-various']


En exercice : installez :mod:`plone.app.discussion`, le nouveau système de
commentaire qui sera intégré dans Plone 4.1

À propos des versions
=====================

Le panneau de configuration :guilabel:`Produits d'extension` accessible via
:guilabel:`Configuration du site` est une interface à
:guilabel:`portal_quickinstaller` et :guilabel:`portal_setup`.

Elle permet d'installer les produits n'ayant pas de profile avec
:guilabel:`portal_quickinstaller` et les produits avec profile avec
:guilabel:`portal_setup`.

Les versions affichées sont celles des eggs. La version est récupérée via le
module :mod:`pkg_resources` fourni par :mod:`setuptools` comme vu précédemment.

La version du egg et du profil peuvent être différentes. Il est même conseillé
dès le départ d'utiliser des versions différentes pour la version du
produit/egg, et la version du profil.

La version du egg est une version de la forme 1.0.0, 1.0.1, 1.1.0 etc. Si vous
modifiez du code Python ou des templates, incrémentez cette version.

La version du profile est un simple entier qui est incrémenté à chaque fois
qu'un fichier est modifié ou ajouté dans le dossier du profile. Vous
incrémenterez généralement aussi la version du egg.

Releaser le policy product
==========================

Maintenant que vous avez un :term:`policy product` qui fait quelque chose, il
est peut-être temps de réaliser une release pour pouvoir l'utiliser en
production. En effet il n'est pas conseillé d'utiliser des produits en mode
développement en production.

La première chose à faire et d'éditer le changelog dans le fichier
:file:`docs/HISTORY.txt`.

Ce fichier texte est au format reST (`reStructuredText`_). Il faut respecter
certaines convention d'écriture pour que ce fichier puisse être généré ensuite
en HTML sur :term:`Pypi`.

- le soulignage d'un titre doit aller exactement jusqu'au bout du titre.
- les listes doivent avoir une ligne vide au début et à la fin

.. _`reStructuredText`: http://docutils.sourceforge.net/rst.html

Pour cette première release, vous allez seulement spécifier la date de la release. Remplacez juste *unreleased* par *2009-06-11*.
Remplacez également la puce de la liste, l'étoile par un tiret qui est la convention dans les produits plone.

Votre fichier doit ressembler à ceci :

.. code-block:: rst

   Changelog
   =========

   1.0 (2009-06-11)
   ----------------

   - Initial release

La version dans :file:`setup.py` doit également être *1.0*.

Commitez :

..  code-block:: sh

    $ svn ci -m "Prepare release"

Maintenant vous allez faire un tag, c'est-à-dire une copie d'une branche qui
sera gelée, faire un checkout de ce tag et pousser la release :

..  code-block:: sh

    $ svn cp http://devagile/Formation/packages/formation.policy/trunk http://devagile/Formation/packages/formation.policy/tags/1.0 -m"Tagged"
    $ cd /tmp
    $ svn co http://devagile/Formation/packages/formation.policy/tags/1.0
    $ cd 1.0/
    $ python setup.py egg_info -RDb "" mregister sdist --formats=zip mupload -r mycompany

Il y a aussi une autre manière de faire, au lieu de préciser ``egg_info -RDb
""``, vous pouvez supprimer le fichier :file:`setup.cfg`, commiter et faire la
release sans préciser ``egg_info -RDb ""``.

Retournez ensuite dans le trunk (dossier :file:`src/formation.policy/`), incrémentez
la version dans :file:`setup.py`, donc ici ``1.1``. Et éditez le fichier :file:`HISTORY.txt` comme ceci :

.. code-block:: rst

   Changelog
   =========

   1.1 (unreleased)
   ----------------

   1.0 (2009-06-11)
   ----------------

   - Initial release

Et commitez :

.. code-block:: sh

    $ svn ci -m "Update version after release"

Vous allez dorénavant utiliser cette version releasé plutôt que le egg en
développement.

Supprimez ``formation.policy`` de l'option ``develop`` de la section ``[buildout]`` dans :file:`buildout.cfg`.

Ajoutez aussi le lien vers le Pypi dans find-links :

.. code-block:: cfg

    [buildout]
    find-links +=
        ...
        http://devagile:8080/site/products/simple

Précisez la version ``formation.policy = 1.0`` dans ``versions.cfg``.

L'external ne sera plus utilisé dans la suite, donc supprimez le également :

.. code-block:: sh

    $ svn rm src/EXTERNALS.txt
    $ svn propdel svn:externals src/
    $ svn ci -m "Removed external"

Pour plus d'informations sur comment faire une release, voyez les liens suivants
:

- http://grok.zope.org/documentation/how-to/releasing-software
- http://plone.org/documentation/tutorial/how-to-upload-your-package-to-plone.org

.. todo:: Evoquer l'utilisation de zest.releaser

Vous pouvez maintenant mettre à jour votre serveur de production. Il est
recommandé de créer une branche production de votre buildout trunk. De cette
manière vous saurez à tout moment quelle version vous avez en production.

Créez la branche :

.. code-block:: sh

    $ svn cp http://devagile/Formation/buildouts/plone4/trunk \
      http://devagile/Formation/buildouts/plone4/branches/production \
      -m "Created production branch"

Sur le serveur, initialement vous avez réalisé un checkout de la branche
production :

.. code-block:: sh

    $ svn co http://devagile/Formation/buildouts/plone4/branches/production \
      plone4
    $ cd plone4
    $ python2.6 -S bootstrap.py
    $ bin/buildout
    $ bin/instance start

Pour les prochaines mises à jour en production, seulement les commandes
suivantes sont nécessaires :

.. code-block:: sh

    $ cd plone4
    $ svn up
    $ bin/buildout
    $ bin/instance restart

.. note::
   Fichiers ``buildout.cfg`` multiples

   Lorsque vous serez familier avec les configurations buildout, vous arriverez
   à faire plusieurs fichiers buildout, un par environnement de déploiement
   (développement, intégration, production, ...), chaque fichier principal
   ``development.cfg``, ``deployment.cfg``, ``deployment-backup.cfg``, étant une extension d'une configuration de
   base ``buildout.cfg`` intégrant tous les modules applicatifs.

.. todo:: Evoquer également :mod:`collective.releaser` qui simplifie pas mal ce processus de release.

Repasser au développement
=========================

Maintenant vous voulez repasser le egg :mod:`formation.policy` en mode
développement pour travailler dessus. Il faut :

- supprimer la version dans versions.cfg
- ajouter le egg dans l'option develop de buildout.cfg
- reconfigurer l'external pour récupérer le egg dans le dossier src

Passer du mode développement au mode production et vice-versa génère beaucoup de
bruit dans les logs svn, mais surtout il faut sans cesse répéter les mêmes
actions.

Nous allons utiliser dans la suite une extension buildout nommée
:mod:`mr.developer` qui s'occupe de réaliser les 3 étapes décrites ci-dessus en
une commande.

Utilisation de mr.developer pour gérer les composants en développement
======================================================================

L'extension pour zc.buildout `mr.developer`_ permet de gérer les composants en
développement, et de commuter facilement d'un composant en développement à sa
version "releasée" et inversement.

Transformez le fichier buildout.cfg :

.. code-block:: cfg

    extends =
        ...
        sources.cfg
    extensions +=
        ...
        mr.developer

Créez le fichier :file:`sources.cfg` avec ce contenu :

.. code-block:: cfg

    [buildout]
    auto-checkout =
        formation.policy

    [sources]
    formation.policy = svn http://devagile/Formation/packages/formation.policy/trunk

Exécutez :command:`bin/buildout` et :mod:`mr.developer` va s'occuper de faire un
checkout de :mod:`formation.policy` dans le dossier :file:`src`.

L'extension s'occupe aussi de passer en mode développement
:mod:`formation.policy` et de supprimer :mod:`formation.policy` de
:file:`versions.cfg` pour que ce soit bien la version en développement qui soit
utilisée. Cela est fait de manière interne, les fichiers ne sont pas touchés.

:mod:`mr.developer` génère le script :command:`bin/develop` qui est un script à
tout faire.

Exécutez :command:`bin/develop help` pour obtenir la liste des commandes, qui
ressemblent beaucoup à subversion.

:command:`bin/develop stat` vous liste les checkouts du dossier :file:`src`,
vous dit s'ils sont actifs ou non (c'est-à-dire en mode développement ou non) et
s'ils sont dans l'option *auto-checkout* ou non. Exécutez :command:`bin/develop
help stat` pour obtenir la légende.

:command:`bin/develop co plonetheme.formation` fait un checkout dans le dossier
:file:`src`, et active le egg (le met en mode développement).

:command:`bin/develop activate plonetheme.formation` suivi de :command:`bin/buildout` permet de passer le egg en mode développement.

:command:`bin/develop deactivate plonetheme.formation` suivi de
:command:`bin/buildout` permet de désactiver le mode développement et d'utiliser
la version spécifiée dans :file:`versions.cfg`.

:command:`bin/develop up -vf` permet de mettre à jour tous les
checkouts. L'option :option:`-v` permet d'afficher les messages de subversion.
L'option :option:`-f` permet de forcer un :command:`svn up` si le checkout est
dans un état pas clean.

L'idée est d'ajouter dans auto-checkout les eggs qui ont été modifiés après leur
dernière release. Comme ceci lorsqu'il est temps de livrer votre travail en
production, vous savez exactement quels sont les eggs dont vous devez faire une
release.

.. _`mr.developer`: http://pypi.python.org/pypi/mr.developer

Mettre à jour la branche de production
======================================

Vous avez commité un changement dans le trunk, il faut le backporter dans la branche production.

Le commit sur le trunk est la révision 1023, pour merger ce commit sur la
branche de production :

.. code-block:: sh

    $ cd path/to/trunk/workingcopy
    $ svn info
    URL : <url_to_repository>/trunk
    trunk$ cd ../branches/production
    branches/production$ svn merge -c 1023 <url_to_repository>/trunk .

Puis il faut commiter le résultat en précisant dans le message les numéros de
versions et leur origine :

.. code-block:: sh

    $ cd path/to/branches/production
    $ svn info
    ...
    Révision : 1025
    ...
    branches/production$ svn ci -m"Merged -r1023:1025 from trunk"


Connaitre les révisions mergées
-------------------------------

Sur un serveur subversion >= 1.5 seulement :

.. code-block:: sh

   $ cd path/to/branches/production
   $ svn mergeinfo <url_to_repository>/trunk .

Connaitre les révisions à merger
--------------------------------

Sur un serveur subversion >= 1.5 seulement :

.. code-block:: sh

   $ cd path/to/branches/production
   $ svn mergeinfo --show-revs eligible <url_to_repository>/trunk .

Fabric
======

Créez un environnement isolé Python >= 2.5 avec Fabric d'installé :

.. code-block:: sh

    $ mkvirtualenv -p /usr/bin/python2.6 --no-site-packages fab
    (fab)$ easy_install Fabric

Création d'un script Fabric pour la maintenance de l'instance Plone à distance.
Créez un fichier :file:`fabfile.py` à la racine de votre buildout :

.. code-block:: python

    from fabric.api import run, sudo, env, hosts

    env.user = "anthony"
    env.hosts = ('devagile',)

    def update():
        """Update the checkout of the buildout
        """
        run("cd /home/anthony/workspace/plone4; svn up")

    def restart():
        """Restart the instance
        """
        run("/home/anthony/workspace/plone4/bin/instance restart")

    def stop():
        """Stop the instance
        """
        run("/home/anthony/workspace/plone4/bin/instance stop")

    def start():
        """Start the instance
        """
        run("/home/anthony/workspace/plone4/bin/instance stop")

    def buildout():
        """Run bin/buildout
        """
        run("cd /home/anthony/workspace/plone4; bin/buildout")

    def up_and_restart():
        """Update the checkout and restart the instance
        """
        update()
        restart()

    def full_up_and_restart():
        """Do the actions stop, update, buildout, start
        """
        stop()
        update()
        buildout()
        start()

Pour afficher la liste des commandes disponibles :

.. code-block:: sh

    $ fab --list
    Available commands:

        buildout             Run bin/buildout
        full_up_and_restart  Do the actions stop, update, buildout, start
        restart              Restart the instance
        start                Start the instance
        stop                 Stop the instance
        up_and_restart       Update the checkout and restart the instance
        update               Update the checkout of the buildout

Pour redémarrer l'instance :

.. code-block:: sh

    $ fab restart

Pour préciser un autre host qui va donc écraser le host configuré globalement
dans le fichier :

.. code-block:: sh

    $ fab stop:host=ailleurs

Vous pouvez aussi créer des commandes avec des paramètres, exécutez
:command:`fab -h` pour consulter la liste des options.

Pour plus de détails, consulter la `documentation de Fabric`_

.. _`documentation de Fabric`: http://docs.fabfile.org/#documentation

Ressources
==========

- http://plone.org/documentation/tutorial/buildout
- http://www.sixfeetup.com/swag/buildout-quick-reference-card
