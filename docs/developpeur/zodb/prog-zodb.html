

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Programmation ZODB &mdash; Plone pour les développeurs 1.0.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Recherchez dans Plone pour les développeurs 1.0.0 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="top" title="Plone pour les développeurs 1.0.0 documentation" href="../index.html" />
    <link rel="up" title="ZODB - Une Base de données objet native pour python" href="index.html" />
    <link rel="next" title="Le guide complet de l&#39;Architecture de Composants de Zope" href="../izca-fr.html" />
    <link rel="prev" title="Tutoriel" href="tutorial.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Index général"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../izca-fr.html" title="Le guide complet de l&#39;Architecture de Composants de Zope"
             accesskey="N">suivant</a> |</li>
        <li class="right" >
          <a href="tutorial.html" title="Tutoriel"
             accesskey="P">précédent</a> |</li>
        <li><a href="../index.html">Formation Plone</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">ZODB - Une Base de données objet native pour python</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="programmation-zodb">
<h1>Programmation ZODB<a class="headerlink" href="#programmation-zodb" title="Lien permanent vers ce titre">¶</a></h1>
<div class="section" id="installation-de-la-zodb">
<h2>Installation de la ZODB<a class="headerlink" href="#installation-de-la-zodb" title="Lien permanent vers ce titre">¶</a></h2>
<p>La ZODB est empaquetée à l'aide des outils standards 'distutils'.</p>
<p>Vous avez besoin au minimum d'une version de Python supérieure ou égale à 2.3.5.</p>
<p>Installez la ZODB avec la commande <strong class="command">easy_install ZODB3</strong> sous Unix
sinon installer les paquets pré-construits pour Windows.</p>
<p>En effet, sous Unix vous aurez besoin d'un compilateur C pour construire le
paquet car la ZODB possède de nombreux modules écrits en C pour des raisons de
performance.</p>
</div>
<div class="section" id="comment-fonctionne-la-zodb">
<h2>Comment fonctionne la ZODB<a class="headerlink" href="#comment-fonctionne-la-zodb" title="Lien permanent vers ce titre">¶</a></h2>
<p>La ZODB est conceptuellement simple. Les classes Python dérivent une classe de
base <tt class="xref py py-class docutils literal"><span class="pre">persistent.Persistent</span></tt> pour être compatibles avec la ZODB. Les
instances des objets persistants sont construits, lorsque le programme
en a besoin, à partir du média de stockage,
qui peut être par exemple un fichier sur le disque, et sont mis en cache dans la mémoire.
La ZODB est prévenue de la
modification des objets, si bien que lorsque une instruction réalise une
modification comme <tt class="docutils literal"><span class="pre">obj.size</span> <span class="pre">=</span> <span class="pre">1</span></tt>, l'objet modifié est marqué 'dirty'. En une
requête tous les objets marqués 'dirty' sont écrits sur le stockage permanent,
cette opération s'appelle valider une transaction (&quot;committing a transaction&quot;
ou &quot;commiter&quot; en langue de développeur).  Une transaction peut aussi être
abandonnée ou annulée, ce qui à pour conséquence d'annuler toutes les
modifications, les objets marqués 'dirty' sont remis à leur état initial
d'avant le début de transaction.</p>
<p>Le terme &quot;transaction&quot; a une signification spécifique en informatique.
Il est extrêmement important que le contenu d'une base de données ne soit pas
corrompue par les crashs logiciels ou matériels, et la plupart des logiciels
de base de données offrent cette protection en ayant quatre caractéristiques :
atomique, consistante, isolée, et durable (ACID) :</p>
<ul class="simple">
<li>atomique : les opérations sont indivisibles, en cas d'échec la suite des
opérations est complètement annulée quelles que soientt le nombre d'opérations
effectuées (rollback), inversement en cas de succès elles sont toutes
appliquées ; en cas de crash cela garantit que la base ne sera pas dans un
état partiellement modifié.</li>
<li>cohérente : en fin de transaction, la base est de nouveau dans un état
cohérent - ce qui n'est pas forcément le cas pendant la transaction. Un contenu final
incohérent provoque l'annulation de la transaction.</li>
<li>isolée : deux transactions simultanées n'ont pas connaissance de modifications
apportées à la base par l'autre tant qu'elle n'a pas été validée (commitée).</li>
<li>durable : une transaction validée ne peut être annulée ou écrasée par une
transaction ayant démarré simultanément. Lorsque la seconde voudra écraser
les données de la première elle se verra annulée. Ce qui provoque l'émission
d'un message d'erreur prévenant l'auteur de la seconde transaction que sa
requête n'a pu aboutir en raison d'un conflit de transaction.</li>
</ul>
<p>La ZODB fournit toutes les caractéristiques ACID.</p>
</div>
<div class="section" id="creer-une-zodb">
<h2>Créer une ZODB<a class="headerlink" href="#creer-une-zodb" title="Lien permanent vers ce titre">¶</a></h2>
<p>Il y a trois interfaces principales fournies par la ZODB : les classes
<tt class="xref py py-class docutils literal"><span class="pre">Storage</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">DB</span></tt>, et <tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt>. Les interfaces
<tt class="xref py py-class docutils literal"><span class="pre">DB</span></tt> et <tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt> ont toutes deux une implémentation unique,
mais il y a plein de classes différentes qui implémentent l'interface
<tt class="xref py py-class docutils literal"><span class="pre">Storage</span></tt>.</p>
<ul class="simple">
<li>Les classes de type <tt class="xref py py-class docutils literal"><span class="pre">Storage</span></tt> sont les couches les plus basses,
manipulant, stockant et restituant les objets depuis les différents types de
stockage. Quelques types de stockage différents ont été écrits, telles les classes
<tt class="xref py py-class docutils literal"><span class="pre">FileStorage</span></tt>, qui utilise un fichier de stockage classique, et
<tt class="xref py py-class docutils literal"><span class="pre">BDBFullStorage</span></tt>, qui utilise le logiciel de la base de données
BerkeleyDB Sleepycat. Vous pouvez écrire votre propre classes Storage qui
stocke les objets dans une base de données relationnelle, par exemple, si
cela convient mieux à votre application. D'autres exemples de stockage,
<tt class="xref py py-class docutils literal"><span class="pre">DemoStorage</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">MappingStorage</span></tt> et <tt class="xref py py-class docutils literal"><span class="pre">RelStorage</span></tt> (storage MySQL),
sont disponibles et peuvent
servir de modèle si vous voulez écrire un nouveau système de stockage.</li>
<li>La classe <tt class="xref py py-class docutils literal"><span class="pre">DB</span></tt> chapeaute le stockage, et réalise la médiation entre
les différentes connexions. Une seule instance de <tt class="xref py py-class docutils literal"><span class="pre">DB</span></tt> est créée par
processus.</li>
<li>Enfin, la classe <tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt> réalise la mise en cache des objets, et
les déplace depuis ou vers la solution de stockage. Un programme muti-threadé
doit ouvrir une instance de <tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt> pour chaque flux d'exécution.
Les différents flux d'exécution peuvent alors modifier les objets et valider
leur modifications indépendamment.</li>
</ul>
<p>Projeter d'utiliser une ZODB demande trois étapes : vous avez à instancier la
classe <tt class="xref py py-class docutils literal"><span class="pre">Storage</span></tt>, et obtenir une connexion sous forme d'une instance de
<tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt> à partir de l'instance de :class:'DB'. Tout cela ne
représente que très peu de ligne de code ::</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ZODB</span> <span class="kn">import</span> <span class="n">FileStorage</span><span class="p">,</span> <span class="n">DB</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">storage</span> <span class="o">=</span> <span class="n">FileStorage</span><span class="o">.</span><span class="n">FileStorage</span><span class="p">(</span><span class="s">&#39;/tmp/test-filestorage.fs&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">db</span> <span class="o">=</span> <span class="n">DB</span><span class="p">(</span><span class="n">storage</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
</pre></div>
</div>
<p>Remarquez que vous pouvez utiliser un système de stockage complètement
différent simplement en changeant la ligne qui instancie la classe du type
<tt class="xref py py-class docutils literal"><span class="pre">Storage</span></tt>, l'exemple précédent utilise <tt class="xref py py-class docutils literal"><span class="pre">FileStorage</span></tt>. Dans la
section <em class="xref std std-ref">zeo</em>, &quot;Comment fonctionne la ZEO&quot;, vous verrez comment ZEO
utilise cette possibilité.</p>
</div>
<div class="section" id="utiliser-un-fichier-de-configuration-pour-la-zodb">
<h2>Utiliser un fichier de configuration pour la ZODB<a class="headerlink" href="#utiliser-un-fichier-de-configuration-pour-la-zodb" title="Lien permanent vers ce titre">¶</a></h2>
<p>La ZODB supporte également les fichiers de configuration écrits dans le format
ZConfig. Un fichier de configuration peut être utilisé pour séparer la
configuration de l'applicatif. Les classes de stockage et la classe <tt class="xref py py-class docutils literal"><span class="pre">DB</span></tt>
supportent divers arguments. Toutes ces options peuvent être spécifiées par
le fichier de configuration.</p>
<p>Le format du fichier est simple, L'exemple du chapitre précédent peut être
réalisé comme suit ::</p>
<div class="highlight-python"><pre>&lt;zodb&gt;
  &lt;filestorage&gt;
  path /tmp/test-filestorage.fs
  &lt;/filestorage&gt;
&lt;/zodb&gt;</pre>
</div>
<p>Le module <tt class="xref py py-mod docutils literal"><span class="pre">ZODB.config</span></tt> inclut plusieurs fonctions pour ouvrir une base de
données et un stockage depuis un fichier de configuration. :python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ZODB.config</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">db</span> <span class="o">=</span> <span class="n">ZODB</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">databaseFromURL</span><span class="p">(</span><span class="s">&#39;/tmp/test.conf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
</pre></div>
</div>
<p>La documentation sur ZConfig est inclue dans la livraison de ZODB3, elle
explique le format en détail. Chaque fichier de configuration est décrit par un
schéma, qui par convention est stocké dans un fichier <tt class="file docutils literal"><span class="pre">component.xml</span></tt>.
ZODB, ZEO, zLOG, et zdaemon ont tous un schéma.</p>
</div>
<div class="section" id="ecriture-d-une-classe-persistante">
<h2>Écriture d'une classe persistante<a class="headerlink" href="#ecriture-d-une-classe-persistante" title="Lien permanent vers ce titre">¶</a></h2>
<p>Faire une classe persistante est assez simple; il suffit de dériver de la
classe <tt class="xref py py-class docutils literal"><span class="pre">Persistent</span></tt>, comme montré dans l'exemple suivant :python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">persistent</span> <span class="kn">import</span> <span class="n">Persistent</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Persistent</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">pass</span>
</pre></div>
</div>
<p>La classe <tt class="xref py py-class docutils literal"><span class="pre">Persistent</span></tt> est une classe de type 'new-style' c'est à dire
qu'elle dérive de <cite>object</cite>. Elle est implémentée en C.</p>
<p>Pour des raisons de simplicité, dans l'exemple la classe <tt class="xref py py-class docutils literal"><span class="pre">User</span></tt> sera
simplement utilisée comme un support à un ensemble d'attributs. Habituellement
la classe devrait définir plusieurs méthodes qui ajoutent des fonctionnalités,
mais cela n'a aucun impact sur le traitement qu'en fait la ZODB.</p>
<p>La ZODB utilise la persistance par accessibilité : à partir d'un ensemble
d'objets racines tous les attributs de ces objets sont rendus persistants, qu'il
s'agisse de type de données Python ou d'instances de classe. Il n'y a pas de
méthode explicite pour stocker les objets dans la base ZODB : ajoutez les
simplement comme attribut à un objet ou dans un dictionnaire qui soit déjà dans
la base. Cette chaîne de contenance doit finir par rejoindre l'objet racine de
la base de données.</p>
<p>Comme exemple, nous allons créer une base de données d'utilisateurs simple qui
permette de récupérer des instances de la classe <tt class="xref py py-class docutils literal"><span class="pre">User</span></tt> pour un ID
d'utilisateur donné. Premièrement, nous récupérons l'objet à la racine primaire
de la ZODB en utilisant la méthode <tt class="xref py py-meth docutils literal"><span class="pre">root</span></tt> de l'instance
<tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt>. L'objet racine se comporte comme un dictionnaire, en
conséquence vous pouvez ajouter une nouvelle entrée clé/valeur pour la racine
de votre application. Nous allons insérer un objet <tt class="xref py py-class docutils literal"><span class="pre">OOBTree</span></tt> qui va
contenir toute les objets <tt class="xref py py-class docutils literal"><span class="pre">User</span></tt>. (Le module <tt class="xref py py-class docutils literal"><span class="pre">BTree</span></tt> est
également inclus comme faisant partie des éléments de Zope.) :python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dbroot</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">root</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Ensure that a &#39;userdb&#39; key is present</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># in the root</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="ow">not</span> <span class="n">dbroot</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;userdb&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="kn">from</span> <span class="nn">BTrees.OOBTree</span> <span class="kn">import</span> <span class="n">OOBTree</span>
<span class="gp">... </span>    <span class="n">dbroot</span><span class="p">[</span><span class="s">&#39;userdb&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">OOBTree</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">userdb</span> <span class="o">=</span> <span class="n">dbroot</span><span class="p">[</span><span class="s">&#39;userdb&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Insérer un nouvel utilisateur est simple : créez un objet de la classe
<tt class="xref py py-class docutils literal"><span class="pre">User</span></tt>, remplissez le avec les données, insérer le dans l'instance du
<tt class="xref py py-class docutils literal"><span class="pre">BTree</span></tt>, et validez (commitez) la transaction.
:python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">newuser</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="s">&#39;amk&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newuser</span><span class="o">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="s">&#39;Andrew&#39;</span> <span class="p">;</span> <span class="n">newuser</span><span class="o">.</span><span class="n">last_name</span> <span class="o">=</span> <span class="s">&#39;Kuchling&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Add object to the BTree, keyed on the ID</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">userdb</span><span class="p">[</span><span class="n">newuser</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">newuser</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Commit the change</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transaction</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
</pre></div>
</div>
<p>Le module <tt class="xref py py-mod docutils literal"><span class="pre">transaction</span></tt> définit quelque fonction de haut niveau pour
travailler avec les transactions. La fonction <tt class="xref py py-func docutils literal"><span class="pre">commit</span></tt> écrit tous les
objets modifiés sur le disque, ce qui rend les modifications permanentes. La
fonction <tt class="xref py py-func docutils literal"><span class="pre">abort</span></tt> annule toutes les modifications qui ont été réalisées
depuis le dernier appel à <tt class="xref py py-func docutils literal"><span class="pre">commit</span></tt>, restaurant l'état initial des objets.
Si vous êtes familier avec la sémantique des bases de données relationnelles,
vous n'êtes pas dépaysé. La fonction <tt class="xref py py-func docutils literal"><span class="pre">get</span></tt> retourne une instance de la
classe <tt class="xref py py-class docutils literal"><span class="pre">Transaction</span></tt> qui ont des méthodes additionnelles comme la
fonction <tt class="xref py py-meth docutils literal"><span class="pre">note</span></tt> qui ajoute une note au métadata de la transaction.</p>
<p>Plus précisément, le module <tt class="xref py py-mod docutils literal"><span class="pre">transaction</span></tt> expose une instance de la classe
de gestion des transactions <tt class="xref py py-class docutils literal"><span class="pre">ThreadTransactionManager</span></tt> comme
<tt class="docutils literal"><span class="pre">transaction.manager</span></tt>, et les fonctions du module <tt class="xref py py-mod docutils literal"><span class="pre">transaction</span></tt> comme
<tt class="xref py py-func docutils literal"><span class="pre">get</span></tt> et <tt class="xref py py-func docutils literal"><span class="pre">begin</span></tt> qui redirige vers des méthodes du même nom du
<tt class="docutils literal"><span class="pre">transaction.manager</span></tt>. La fonction <tt class="xref py py-func docutils literal"><span class="pre">commit</span></tt> et <tt class="xref py py-func docutils literal"><span class="pre">abort</span></tt> appliquent
les méthodes de même nom de l'instance de la classe <tt class="xref py py-class docutils literal"><span class="pre">Transaction</span></tt>
retourné par <tt class="docutils literal"><span class="pre">transaction.manager.get()</span></tt>. Tout ceci pour des raisons de
commodité. Il est également possible de créer votre propre gestionnaire de
transaction, et de dire à <tt class="docutils literal"><span class="pre">DB.open()</span></tt> de l'utiliser à la place.</p>
<p>Par ce que l'intégration avec Python est complète, c'est presque comme avoir
une sémantique transactionnelle pour les variables de vos programme, vous
pouvez expérimenter les transactions dans un interpréteur Python : :python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">newuser</span>
<span class="go">&lt;User instance at 81b1f40&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newuser</span><span class="o">.</span><span class="n">first_name</span>           <span class="c"># Print initial value</span>
<span class="go">&#39;Andrew&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newuser</span><span class="o">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="s">&#39;Bob&#39;</span>   <span class="c"># Change first name</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newuser</span><span class="o">.</span><span class="n">first_name</span>           <span class="c"># Verify the change</span>
<span class="go">&#39;Bob&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transaction</span><span class="o">.</span><span class="n">abort</span><span class="p">()</span>          <span class="c"># Abort transaction</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newuser</span><span class="o">.</span><span class="n">first_name</span>           <span class="c"># The value has changed back</span>
<span class="go">&#39;Andrew&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="regles-d-ecriture-de-classes-persistantes">
<h2>Règles d'écriture de classes persistantes<a class="headerlink" href="#regles-d-ecriture-de-classes-persistantes" title="Lien permanent vers ce titre">¶</a></h2>
<p>Pratiquement tous les langages persistants imposent des restrictions sur le
style des programmes, avertissant des constructions qu'ils ne peuvent gérer ou
y ajoutent de subtiles modifications sémantiques, et la ZODB ne fait pas
exception. Heureusement, les restrictions de la ZODB sont assez simples à
comprendre, et dans la pratique il n'est pas douloureux de les contourner.</p>
<p>Le résumé des règles est le suivant :</p>
<ul class="simple">
<li>Si vous modifiez un objet mutable qui est la valeur d'un attribut d'un autre
objet la ZODB ne peut le savoir, et ne marquera pas l'objet comme 'dirty'.
La solution consiste soit à positionner le drapeau 'dirty' vous même quand
vous modifiez l'objet, soit à utiliser un 'wrapper' (un objet enveloppe qui
fournit les services manquants) pour les listes et les dictionnaires Python
(<tt class="xref py py-class docutils literal"><span class="pre">PersistentList</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">PersistentMapping</span></tt>) qui positionne le
drapeau 'dirty' proprement.</li>
<li>Les versions récentes de la ZODB autorisent l'écriture de classe qui ont des
méthodes <tt class="xref py py-meth docutils literal"><span class="pre">__setattr__</span></tt>, <tt class="xref py py-meth docutils literal"><span class="pre">__getattr__</span></tt>, ou <tt class="xref py py-meth docutils literal"><span class="pre">__delattr__</span></tt>. Ce
que ne permettaient pas du tout les anciennes versions. Si vous écrivez des
méthodes <tt class="xref py py-meth docutils literal"><span class="pre">__setattr__</span></tt> ou <tt class="xref py py-meth docutils literal"><span class="pre">__delattr__</span></tt>, leur code doit
positionner le drapeau 'dirty' manuellement.</li>
<li>Une classe persistante ne doit pas avoir de méthode <tt class="xref py py-meth docutils literal"><span class="pre">__del__</span></tt>. La base
de données doit pouvoir déplacer librement les objets entre le système de
stockage et la mémoire. Si un objet n'est pas utilisé depuis un moment, il
peut être relâché et son contenu chargé depuis le système de stockage à la
prochaine utilisation. Parce que l'interpréteur Python n'est pas conscient
des mécanismes de persistance, il pourrait appeler la méthode <tt class="xref py py-meth docutils literal"><span class="pre">__del__</span></tt>
chaque fois que l'objet a été libéré.</li>
</ul>
<p>Nous allons regarder chaque règle en détail.</p>
<div class="section" id="modification-des-objets-modifiables">
<h3>Modification des objets modifiables<a class="headerlink" href="#modification-des-objets-modifiables" title="Lien permanent vers ce titre">¶</a></h3>
<p>La ZODB utilise différents hameçons Python pour attraper les accès aux
attributs, et peut détourner la majorité des façons de modifier un objet, mais
pas tous. Si vous modifiez un objet de la classe <tt class="xref py py-class docutils literal"><span class="pre">User</span></tt> par affectation
d'un de ses attributs, comme dans <tt class="docutils literal"><span class="pre">userobj.first_name</span> <span class="pre">=</span> <span class="pre">'Andrew'</span></tt>, la ZODB va
marquer l'objet comme ayant changé, et il sera écrit dans le système de
stockage lors du prochain <tt class="xref py py-meth docutils literal"><span class="pre">commit</span></tt> (validation).</p>
<p>Le cas le plus typique qui n'est pas pris en charge par la ZODB est la liste ou
le dictionnaire. Si les objets de type <tt class="xref py py-class docutils literal"><span class="pre">User</span></tt> ont un attribut nommé
<tt class="docutils literal"><span class="pre">friends</span></tt> contenant une liste, appelant <tt class="docutils literal"><span class="pre">userobj.friends.append(otherUser)</span></tt>
qui ne marque pas <tt class="docutils literal"><span class="pre">userobj</span></tt> comme étant modifié. Du point de vue de la ZODB,
<tt class="docutils literal"><span class="pre">userobj.friends</span></tt> n'a été que lu, et sa valeur, ce qui arrive à une liste
Python ordinaire, a été retournée. La ZODB n'est pas consciente que l'objet
retourné a été modifié après.</p>
<p>C'est l'une des quelque bizarreries dont vous devez vous rappeler quand vous
utilisez la ZODB : si vous modifiez un objet modifiable attribut d'un objet en
place, vous devez marquer manuellement l'objet qui a été modifié pour que son
drapeau 'dirty' soit à vrai. Ceci est fait en positionnant l'attribut
<tt class="xref py py-attr docutils literal"><span class="pre">_p_changed</span></tt> de l'objet à vrai :python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">userobj</span><span class="o">.</span><span class="n">friends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">otherUser</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">userobj</span><span class="o">.</span><span class="n">_p_changed</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
<p>Vous pouvez cacher le détails d'implémentation du marquage de l'objet
comme 'dirty' en concevant l'API de vos classes pour qu'elles
n'utilisent pas directement l'accès aux attributs. En lieu et place, vous
pouvez utiliser l'approche Java des accesseurs pour tout, et positionner le
drapeau de modification à l'intérieur des méthodes. Par exemple, vous pouvez
interdire l'accès direct à l'attribut <tt class="docutils literal"><span class="pre">friends</span></tt>, et ajouter une méthode
<tt class="xref py py-meth docutils literal"><span class="pre">get_friend_list</span></tt> et une méthode <tt class="xref py py-meth docutils literal"><span class="pre">add_friend</span></tt> de modification.
La méthode <tt class="xref py py-meth docutils literal"><span class="pre">add_friend</span></tt> devrait ressembler à :python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">add_friend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">friend</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="bp">self</span><span class="o">.</span><span class="n">friends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">otherUser</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="bp">self</span><span class="o">.</span><span class="n">_p_changed</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
<p>Vous pouvez aussi utiliser le mécanisme des 'properties' pour cacher les
accesseurs à l'usage (&#64;property).</p>
<p>Vous pouvez également utiliser une liste ou un dictionnaire compatible avec la
ZODB qui gère pour vous le drapeau de modification. La ZODB est fournie avec la
classe <tt class="xref py py-class docutils literal"><span class="pre">PersistentMapping</span></tt> et <tt class="xref py py-class docutils literal"><span class="pre">PersistentList</span></tt></p>
<p>Vous pouvez rendre silencieuses les modifications d'un objet en changeant la
valeur du drapeau de modification (_p_changed ) à False.</p>
</div>
<div class="section" id="getattr-delattr-and-setattr">
<h3><tt class="xref py py-meth docutils literal"><span class="pre">__getattr__</span></tt>, <tt class="xref py py-meth docutils literal"><span class="pre">__delattr__</span></tt>, and <tt class="xref py py-meth docutils literal"><span class="pre">__setattr__</span></tt><a class="headerlink" href="#getattr-delattr-and-setattr" title="Lien permanent vers ce titre">¶</a></h3>
<p>La ZODB autorise la persistance des classes qui ont des méthodes crochets comme
<tt class="xref py py-meth docutils literal"><span class="pre">__getattr__</span></tt> et <tt class="xref py py-meth docutils literal"><span class="pre">__setattr__</span></tt>. Il y a quatre méthodes spéciales
qui contrôlent l'accès aux attributs : les règles de chacune diffèrent.</p>
<p>La méthode <tt class="xref py py-meth docutils literal"><span class="pre">__getattr__</span></tt> fonctionne presque de la même façon pour les
classes persistantes que pour les autres classes. Pas besoin de manipuler quoi
que ce soit. Si un objet est rendu silencieux, il devra être manipulé avant
l'appel à <tt class="xref py py-meth docutils literal"><span class="pre">__getattr__</span></tt>.</p>
<p>Les autres méthodes sont plus délicates. Elles vont surcharger les crochets
fournis par la <tt class="xref py py-class docutils literal"><span class="pre">Persistent</span></tt>, si bien que l'utilisateur doit appeler des
méthodes spéciales pour invoquer ces crochets.</p>
<p>La méthode <tt class="xref py py-meth docutils literal"><span class="pre">__getattribute__</span></tt> sera appelée pour les accès aux attributs :
Elle surcharge l'accès au code fourni lors de la dérivation de la classe
<tt class="xref py py-class docutils literal"><span class="pre">Persistent</span></tt>. Une méthode <tt class="xref py py-meth docutils literal"><span class="pre">__getattribute__</span></tt> surchargée par
l'utilisateur doit toujours faire en sorte que la classe de base
<tt class="xref py py-class docutils literal"><span class="pre">Persistent</span></tt> ait une chance de manipuler les attributs spéciaux comme
<tt class="xref py py-attr docutils literal"><span class="pre">__dict__</span></tt> ou <tt class="xref py py-attr docutils literal"><span class="pre">__class__</span></tt>. La surcharge doit appeler la méthode
<tt class="xref py py-meth docutils literal"><span class="pre">_p_getattr</span></tt>, et doit lui passer comme seul argument le nom de
l'attribut. Si elle retourne True, le code de la fonction surchargée par
l'utilisateur doit appeler la méthode <tt class="xref py py-meth docutils literal"><span class="pre">__getattribute__</span></tt> de la classe
<tt class="xref py py-class docutils literal"><span class="pre">Persistent</span></tt> pour obtenir la valeur. Sinon le code peut continuer sont
exécution.</p>
<p>Un crochet de la méthode <tt class="xref py py-meth docutils literal"><span class="pre">__setattr__</span></tt> va également surcharger la méthode
<tt class="xref py py-meth docutils literal"><span class="pre">__setattr__</span></tt> de la classe <tt class="xref py py-class docutils literal"><span class="pre">Persistent</span></tt> et l'utilisateur doit la
traiter un peu comme la précédente. Le code réalisé par l'utilisateur doit
appeler la méthode <tt class="xref py py-meth docutils literal"><span class="pre">_p_setattr</span></tt> de la classe <tt class="xref py py-class docutils literal"><span class="pre">Persistent</span></tt> en lui
passant le nom et la valeur de l'attribut. Si la méthode retourne True, la
classe <tt class="xref py py-class docutils literal"><span class="pre">Persistent</span></tt> gère l'attribut, sinon le code peut continuer sont
exécution. Si le code de l'utilisateur modifie l'état de l'objet, le code doit
positionner l'attribut <tt class="xref py py-attr docutils literal"><span class="pre">_p_changed</span></tt>.</p>
<p>Le crochet de la méthode meth:<cite>__delattr__</cite> doit être implémenté de la même
façon. Le code de l'utilisateur doit appeler <tt class="xref py py-meth docutils literal"><span class="pre">_p_delattr</span></tt>,  en passant le
nom de l'attribut comme argument. Si l'appel renvoit True alors la classe
<tt class="xref py py-class docutils literal"><span class="pre">Persistent</span></tt> gère l'attribut sinon c'est au code de l'utilisateur de le
faire.</p>
</div>
<div class="section" id="methode-del">
<h3>Méthode <tt class="xref py py-meth docutils literal"><span class="pre">__del__</span></tt><a class="headerlink" href="#methode-del" title="Lien permanent vers ce titre">¶</a></h3>
<p>La méthode <tt class="xref py py-meth docutils literal"><span class="pre">__del__</span></tt> est invoquée juste avant que la mémoire occupée par
un objet Python non référencé soit libérée. Parce que la ZODB peut
matérialiser ou dématérialiser un objet persistant en mémoire un nombre
quelconque de fois, il y a une relation très forte entre la persistance d'un
objet et la méthode <tt class="xref py py-meth docutils literal"><span class="pre">__del__</span></tt> qui est normalement invoquée durant le
cycle de vie de l'objet. Par exemple, la méthode <tt class="xref py py-meth docutils literal"><span class="pre">__del__</span></tt> d'un objet
persistant n'est pas invoqué uniquement dans le cas d'un objet qui n'est plus
référencé par d'autres objets de la base de donnée car la méthode
<tt class="xref py py-meth docutils literal"><span class="pre">__del__</span></tt> est aussi mise en jeu dans le cas de l'accessibilité des objets
en mémoire.</p>
<p>Pire, une méthode <tt class="xref py py-meth docutils literal"><span class="pre">__del__</span></tt> peut interférer avec l'objectif de la
machinerie de persistance. Par exemple, de nombreux objets restent dans le cache
d'une class:<cite>Connection</cite>. À plusieurs reprises, pour réduire la charge du
cache, les objets qui n'ont pas été référencés récemment sont enlevés du cache.
Si un objet persistant est enlevé du cache et que le cache contenait la
dernière référence en mémoire de cet objet la méthode <tt class="xref py py-meth docutils literal"><span class="pre">__del__</span></tt> de
l'objet sera appelée. Si la méthode <tt class="xref py py-meth docutils literal"><span class="pre">__del__</span></tt> référence n'importe quel
attribut de l'objet, la ZODB devra recharger l'objet à partir de la base de
données à nouveau, avant de pouvoir satisfaire la référence. Ce qui a pour
conséquence de remettre l'objet dans le cache. Un tel objet est virtuellement
immortel, occupant de l'espace en mémoire pour toujours, puisque chaque essai
pour l'enlever du cache abouti à l'y remettre. Avec les ZODB antérieures à la
version 3.2.2 cela causait le bouclage infini du code de réduction de la taille
du cache. Cette boucle infinie ne se produit plus mais les objets continuent à
vivre en cache pour toujours.</p>
<p>Parce que la méthode <tt class="xref py py-meth docutils literal"><span class="pre">__del__</span></tt> n'a pas beaucoup de sens dans le cas
d'objets persistants et peut créer des problèmes, les méthodes persistantes ne
devraient pas surcharger la méthode <tt class="xref py py-meth docutils literal"><span class="pre">__del__</span></tt>.</p>
</div>
<div class="section" id="ecrire-des-classes-persistantes">
<h3>Écrire des classes persistantes<a class="headerlink" href="#ecrire-des-classes-persistantes" title="Lien permanent vers ce titre">¶</a></h3>
<p>Maintenant que nous connaissons les bases de la programmation de la ZODB, nous
allons regarder quelques tâches plus délicates qui sont nécessaires à tous les
utilisateurs de la ZODB dans un système en production.</p>
</div>
<div class="section" id="modifier-les-attributs-d-une-instance">
<h3>Modifier les attributs d'une instance<a class="headerlink" href="#modifier-les-attributs-d-une-instance" title="Lien permanent vers ce titre">¶</a></h3>
<p>Idéalement, avant de rendre des classes persistantes, vous voulez définir leur
interface correctement du premier coup, en conséquence de quoi il n'y aurait
pas besoin d'ajouter de nouveaux attributs au cours du temps. C'est un objectif
difficile et  pratiquement impossible à atteindre à moins de connaître
exactement vos besoins futurs. De telles demandes peuvent être réclamées par
d'autres personnes, si bien que vous devez vous préparer à recevoir des
demandes impliquant des changement structurels. En terminologie de base de
données orientées objets, cela s'appelle une mise à jour du schéma. La ZODB n'a
pas besoin de spécification du schéma, si vous changez ce que le logiciel
attend comme données de la base pour un objet, vous changez implicitement le
schéma.</p>
<p>Une façon de gérer de tels changements est de réaliser des programmes qui vont
chercher tous les objets de la base pour les mettre à jour selon le nouveau
schéma. C'est facile si votre réseau d'objet est bien structuré, par exemple si
toutes les instances de la classe <tt class="xref py py-class docutils literal"><span class="pre">User</span></tt> se trouvent dans un unique
dictionnaire ou BTree, il suffit alors de boucler sur chaque instance
<tt class="xref py py-class docutils literal"><span class="pre">User</span></tt>. C'est plus difficile si le graphe est moins structuré. Si vos
objets <tt class="xref py py-class docutils literal"><span class="pre">User</span></tt> ne peuvent être trouvés comme attributs d'un faible nombre
d'objets, il vous faudra écrire un traverseur qui parcourera la base et qui
vérifiera que chaque objet de la ZODB est du type <tt class="xref py py-class docutils literal"><span class="pre">User</span></tt> ou non.</p>
<p>Certaines OODBs supportent une fonctionnalité appelée &quot;extends&quot;, qui peut
rapidement trouver les objets d'un type données, quelque soit le graphe des
objets, malheureusement ce n'est pas le cas de la ZODB.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table des matières</a></h3>
  <ul>
<li><a class="reference internal" href="#">Programmation ZODB</a><ul>
<li><a class="reference internal" href="#installation-de-la-zodb">Installation de la ZODB</a></li>
<li><a class="reference internal" href="#comment-fonctionne-la-zodb">Comment fonctionne la ZODB</a></li>
<li><a class="reference internal" href="#creer-une-zodb">Créer une ZODB</a></li>
<li><a class="reference internal" href="#utiliser-un-fichier-de-configuration-pour-la-zodb">Utiliser un fichier de configuration pour la ZODB</a></li>
<li><a class="reference internal" href="#ecriture-d-une-classe-persistante">Écriture d'une classe persistante</a></li>
<li><a class="reference internal" href="#regles-d-ecriture-de-classes-persistantes">Règles d'écriture de classes persistantes</a><ul>
<li><a class="reference internal" href="#modification-des-objets-modifiables">Modification des objets modifiables</a></li>
<li><a class="reference internal" href="#getattr-delattr-and-setattr"><tt class="docutils literal"><span class="pre">__getattr__</span></tt>, <tt class="docutils literal"><span class="pre">__delattr__</span></tt>, and <tt class="docutils literal"><span class="pre">__setattr__</span></tt></a></li>
<li><a class="reference internal" href="#methode-del">Méthode <tt class="docutils literal"><span class="pre">__del__</span></tt></a></li>
<li><a class="reference internal" href="#ecrire-des-classes-persistantes">Écrire des classes persistantes</a></li>
<li><a class="reference internal" href="#modifier-les-attributs-d-une-instance">Modifier les attributs d'une instance</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Sujet précédent</h4>
  <p class="topless"><a href="tutorial.html"
                        title="Chapitre précédent">Tutoriel</a></p>
  <h4>Sujet suivant</h4>
  <p class="topless"><a href="../izca-fr.html"
                        title="Chapitre suivant">Le guide complet de l'Architecture de Composants de Zope</a></p>
  <h3>Cette page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/zodb/prog-zodb.txt"
           rel="nofollow">Montrer la source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Recherche rapide</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Saisissez un mot clef ou un nom de module, classe ou fonction.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Index général"
             >index</a></li>
        <li class="right" >
          <a href="../izca-fr.html" title="Le guide complet de l&#39;Architecture de Composants de Zope"
             >suivant</a> |</li>
        <li class="right" >
          <a href="tutorial.html" title="Tutoriel"
             >précédent</a> |</li>
        <li><a href="../index.html">Formation Plone</a> &raquo;</li>
          <li><a href="index.html" >ZODB - Une Base de données objet native pour python</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010-2013, Communauté Plone francophone.
      Mis à jour le  07-February-2013.
      Créé avec <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>